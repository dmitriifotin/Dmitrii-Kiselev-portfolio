As more threads are used to run separate ranges of the program, the overall program runtime goes down. It seems that the performance improvement doesn't scale linearly but logarithmically, as there amount of time spent on context switching hinders the performance as more threads are used. Additionally, each thread still needs to access the total counter in a separate time slice to avoid concurrent access to the same variable by multiple threads (and incorrect results due to that).
Intially, I had issues with making sure each thread has a set of local variables for the intermediate counter, current row and current column, so I locked all values. It worked correctly, i.e. totals added up and I tested some small row/col values, but the program didn't show any performance improvement due to multithreading. I then made sure these three variables were local to each thread and set up locked "per thread" access to the total counter.
I double-checked that all threads execute and exit successfully. I added the test code that prints the occurence each thread found to show that each thread executed and I did the math on the calculator to make sure that the total occurences found were equal to the sum of individual thread occurence counters.